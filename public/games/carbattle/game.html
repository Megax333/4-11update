<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Car Racing Game (Babylon.js) - V35 Steering Swap</title> {/* Updated Title */}
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #infoOverlay {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            z-index: 10;
            text-align: center;
            white-space: nowrap;
        }
        #controllerStatus {
             margin-top: 5px;
             font-weight: bold;
        }
        #speedometer {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 1rem;
            z-index: 10;
        }
        #powerupDisplay {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(50, 50, 150, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 1rem;
            z-index: 10;
        }
        #scoreDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 1rem;
            z-index: 10;
            text-align: right;
        }
    </style>
</head>
<body class="bg-gray-800">

    <canvas id="renderCanvas"></canvas>

    <div id="infoOverlay" class="text-white rounded-lg shadow-lg">
        <span>Left Stick: Steer | RT: Accel | LT: Brake/Rev | A: Use Powerup</span>
        <div id="controllerStatus">Status: Disconnected</div>
    </div>

    <div id="speedometer">Speed: 0</div>
    <div id="powerupDisplay">Powerup: None</div>
    <div id="scoreDisplay">Score: 0 - 0</div>

    <script>
        // --- Global Variables ---
        // ... (Keep all other global variables the same) ...
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, antialias: true });
        let scene;
        let carRoot; // Player car parent node
        let camera;
        let controller = null;
        let controllerStatusDiv;
        let speedometerDiv;
        let powerupDisplayDiv;
        let scoreDisplayDiv; // Score UI
        let playerScore = 0;
        let aiScore = 0;
        let playerIsActive = true;
        const playerRespawnTime = 3000;
        let playerRespawnTimer = null;
        let carSpeed = 0;
        let steeringAngle = 0;
        const maxSpeed = 1.0;
        const acceleration = 0.015;
        const deceleration = 0.008;
        const braking = 0.03;
        const reverseAcceleration = 0.01;
        const steeringSpeed = 0.035;
        const maxSteeringAngle = Math.PI / 6;
        const steeringLerpFactor = 0.1;
        const turnFactor = 2.8;
        let wheelRadius = 0.4;
        const wheelYOffset = -0.2;
        let playerActivePowerup = null;
        let powerupsInScene = [];
        const powerupRespawnTime = 10000;
        const powerupCollectionDistance = 3.0;
        const aiPowerupSeekDistance = 40.0;
        let playerProjectiles = [];
        let aiProjectiles = [];
        const projectileSpeed = 3.0;
        const projectileLifetime = 1500;
        const projectileHitDistance = 2.5;
        let shootButtonPressed = false;
        let isAccelerating = false;
        let aiCarRoot;
        let aiCarSpeed = 0.5;
        let aiTargetPath = [];
        let aiCurrentTargetIndex = 0;
        const aiTurnSpeed = 0.05;
        const aiWaypointThreshold = 5.0;
        let aiIsActive = true;
        const aiRespawnTime = 5000;
        let aiRespawnTimer = null;
        let aiActivePowerup = null;
        let aiTargetPowerup = null;
        let aiShootCooldown = 0;
        const aiShootInterval = 1000;
        const aiShootingRange = 50.0;
        const aiShootingAngle = Math.PI / 12;
        let audioContext;
        let engineSound;
        let drivingSound;
        let screechSound;
        let isScreeching = false;
        const screechThresholdAngle = Math.PI / 10;
        const screechThresholdSpeed = 0.5;
        const audioRampTime = 0.1;


        function initializeAudio() { /* ... same ... */
             if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
                 audioContext = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext initialized.");
                 const engineOscillator = audioContext.createOscillator(); const engineGain = audioContext.createGain();
                 engineOscillator.type = 'sine'; engineOscillator.frequency.setValueAtTime(60, audioContext.currentTime); engineGain.gain.setValueAtTime(0, audioContext.currentTime);
                 engineOscillator.connect(engineGain).connect(audioContext.destination); engineOscillator.start();
                 engineSound = { oscillator: engineOscillator, gain: engineGain, baseFreq: 60, maxFreq: 150, maxGain: 0.25 };
                 const drivingNoise = audioContext.createBufferSource(); const bufferSize = audioContext.sampleRate * 1; const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                 const output = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
                 drivingNoise.buffer = buffer; drivingNoise.loop = true; const drivingGain = audioContext.createGain(); drivingGain.gain.setValueAtTime(0, audioContext.currentTime);
                 drivingNoise.connect(drivingGain).connect(audioContext.destination); drivingNoise.start();
                 drivingSound = { source: drivingNoise, gain: drivingGain, maxGain: 0.08 };
                 const screechGain = audioContext.createGain(); screechGain.gain.setValueAtTime(0, audioContext.currentTime); screechGain.connect(audioContext.destination);
                 screechSound = { gain: screechGain, source: null }; console.log("Audio nodes created.");
             }
          }

        // --- Scene Creation ---
        function createScene() { /* ... same ... */
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.53, 0.81, 0.92);
            scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR; scene.fogColor = scene.clearColor;
            scene.fogStart = 150.0; scene.fogEnd = 400.0;
            controllerStatusDiv = document.getElementById('controllerStatus');
            speedometerDiv = document.getElementById('speedometer');
            powerupDisplayDiv = document.getElementById('powerupDisplay');
            scoreDisplayDiv = document.getElementById('scoreDisplay');
            updateScoreDisplay();
            camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 20, -40), scene);
            camera.radius = 18; camera.heightOffset = 8; camera.rotationOffset = 0;
            camera.cameraAcceleration = 0.05; camera.maxCameraSpeed = 15;
            const light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0.1, 1, 0), scene); light.intensity = 0.8;
            const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-0.5, -1, 0.4), scene); dirLight.position = new BABYLON.Vector3(60, 80, 40); dirLight.intensity = 0.9;
            const shadowGenerator = new BABYLON.ShadowGenerator(1024, dirLight); shadowGenerator.useBlurExponentialShadowMap = true; shadowGenerator.blurKernel = 32; shadowGenerator.setDarkness(0.4);
            const groundSize = 600; const groundSubdivisions = 100;
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: groundSize, height: groundSize, subdivisions: groundSubdivisions}, scene);
            const groundMaterial = new BABYLON.StandardMaterial("groundMat", scene); groundMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.6, 0.2); groundMaterial.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05); ground.material = groundMaterial; ground.receiveShadows = true; ground.position.y = -0.5;
            const groundVertices = ground.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            if (groundVertices) {
                for (let i = 0; i < groundVertices.length; i += 3) {
                    const x = groundVertices[i]; const z = groundVertices[i + 2];
                    const distFromCenter = Math.sqrt(x*x + z*z); let height = 0;
                    if (distFromCenter > 100) { height = (Math.sin(x * 0.02) + Math.cos(z * 0.03)) * 2.0 * Math.max(0, (distFromCenter - 100) / 200) ; }
                    groundVertices[i + 1] = height;
                }
                ground.updateVerticesData(BABYLON.VertexBuffer.PositionKind, groundVertices); ground.refreshBoundingInfo(true);
            } else { console.warn("Could not get ground vertices data."); }
            const trackWidth = 12; const outerRadiusX = 80; const outerRadiusZ = 160;
            const innerRadiusX = outerRadiusX - trackWidth; const innerRadiusZ = outerRadiusZ - trackWidth;
            const numAiPathPoints = 20;
            aiTargetPath = [];
            const numRefPoints = 100;
            for (let i = 0; i <= numRefPoints; i++) {
                if (i % Math.floor(numRefPoints / numAiPathPoints) === 0) {
                    const angle = (i / numRefPoints) * Math.PI * 2;
                    const randomRadiusFactor = Math.random();
                    const pathRadiusX = innerRadiusX + (outerRadiusX - innerRadiusX) * randomRadiusFactor;
                    const pathRadiusZ = innerRadiusZ + (outerRadiusZ - innerRadiusZ) * randomRadiusFactor;
                    const angleVariation = Math.random() * 0.05 - 0.025;
                    const pathX = pathRadiusX * Math.sin(angle + angleVariation);
                    const pathZ = pathRadiusZ * Math.cos(angle + angleVariation);
                    aiTargetPath.push(new BABYLON.Vector3(pathX, 0.5, pathZ));
                }
            }
            console.log(`Generated ${aiTargetPath.length} AI path points.`);
            carRoot = createPlayerCar(scene, shadowGenerator);
            carRoot.position = new BABYLON.Vector3(0, 0.5, outerRadiusZ);
            playerIsActive = true;
            console.log("Player car created at:", carRoot.position, "Rotation:", carRoot.rotation);
            aiCarRoot = createAICar(scene, shadowGenerator);
            aiCurrentTargetIndex = 0;
            if (aiTargetPath.length > 0) {
                const startPosIndex = Math.max(0, aiTargetPath.length - 5);
                aiCarRoot.position = aiTargetPath[startPosIndex].clone();
                aiCurrentTargetIndex = (startPosIndex + 1) % aiTargetPath.length;
                 if (aiTargetPath[aiCurrentTargetIndex]) { aiCarRoot.lookAt(aiTargetPath[aiCurrentTargetIndex]); }
                 else { console.warn("AI initial lookAt target is undefined."); aiCarRoot.rotation = BABYLON.Vector3.Zero(); }
                console.log(`AI car created at index ${startPosIndex}:`, aiCarRoot.position, "Targeting index:", aiCurrentTargetIndex);
            } else { aiCarRoot.position = new BABYLON.Vector3(outerRadiusX, 0.5, 0); console.warn("AI target path is empty, using fallback position."); }
            aiIsActive = true;
            aiCarRoot.setEnabled(true);
            const rockMaterial = new BABYLON.StandardMaterial("rockMat", scene); rockMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5); rockMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            const treeTrunkMaterial = new BABYLON.StandardMaterial("trunkMat", scene); treeTrunkMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.25, 0.1);
            const treeLeavesMaterial = new BABYLON.StandardMaterial("leavesMat", scene); treeLeavesMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.5, 0.1);
            const sceneryPositions = [ new BABYLON.Vector3(100, 0, 100), new BABYLON.Vector3(-120, 0, 80), new BABYLON.Vector3(80, 0, -150), new BABYLON.Vector3(-90, 0, -180), new BABYLON.Vector3(150, 0, 0), new BABYLON.Vector3(-150, 0, -30), new BABYLON.Vector3(50, 0, 200), new BABYLON.Vector3(-60, 0, 180), ];
            sceneryPositions.forEach((pos, index) => {
                let groundHeight = ground.position.y;
                const distFromCenter = Math.sqrt(pos.x*pos.x + pos.z*pos.z);
                if (distFromCenter > 100) { groundHeight += (Math.sin(pos.x * 0.02) + Math.cos(pos.z * 0.03)) * 2.0 * Math.max(0, (distFromCenter - 100) / 200) ; }
                if (index % 2 === 0) { const rockSize = Math.random() * 3 + 2; const rock = BABYLON.MeshBuilder.CreateSphere(`rock_${index}`, {diameter: rockSize, segments: 12}, scene); rock.material = rockMaterial; rock.position = pos.clone(); rock.position.y = groundHeight + rockSize * 0.4; shadowGenerator.addShadowCaster(rock); rock.receiveShadows = true; }
                else { const trunkHeight = Math.random() * 4 + 5; const leavesRadius = Math.random() * 2 + 2; const trunk = BABYLON.MeshBuilder.CreateCylinder(`trunk_${index}`, {height: trunkHeight, diameter: 0.8}, scene); trunk.material = treeTrunkMaterial; trunk.position = pos.clone(); trunk.position.y = groundHeight + trunkHeight / 2; shadowGenerator.addShadowCaster(trunk); trunk.receiveShadows = true; const leaves = BABYLON.MeshBuilder.CreateSphere(`leaves_${index}`, {diameter: leavesRadius * 2, segments: 12}, scene); leaves.material = treeLeavesMaterial; leaves.position = trunk.position.clone(); leaves.position.y += trunkHeight / 2; shadowGenerator.addShadowCaster(leaves); leaves.receiveShadows = true; }
            });
            console.log("Scenery created.");
            createPowerup("shooter", new BABYLON.Vector3(50, 1, 50));
            createPowerup("shooter", new BABYLON.Vector3(-50, 1, -50));
            createPowerup("shooter", new BABYLON.Vector3(0, 1, -outerRadiusZ - 20));
            camera.lockedTarget = carRoot;
            setupGamepadListeners();
            initializeAudio();
            return scene;
        }

        // --- Car Creation Functions --- (No changes)
        function createPlayerCar(scene, shadowGenerator) { /* ... same ... */
             const root = new BABYLON.TransformNode("playerCarRoot");
             const bodyMat = new BABYLON.StandardMaterial("playerBodyMat", scene); bodyMat.diffuseColor = new BABYLON.Color3(0.9, 0.1, 0.1); bodyMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
             const glassMat = new BABYLON.StandardMaterial("playerGlassMat", scene); glassMat.diffuseColor = new BABYLON.Color3(0.6, 0.8, 1.0); glassMat.alpha = 0.4; glassMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);
             const detailMat = new BABYLON.StandardMaterial("playerDetailMat", scene); detailMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
             const chassis = BABYLON.MeshBuilder.CreateBox("playerChassis", {width: 2.2, height: 0.7, depth: 4.2}, scene); chassis.material = bodyMat; chassis.position.y = 0; chassis.parent = root; shadowGenerator.addShadowCaster(chassis);
             const cabinBase = BABYLON.MeshBuilder.CreateBox("playerCabinBase", {width: 1.7, height: 0.6, depth: 2.0}, scene); cabinBase.material = bodyMat; cabinBase.position.y = 0.7 / 2 + 0.6 / 2; cabinBase.position.z = -0.5; cabinBase.parent = root; shadowGenerator.addShadowCaster(cabinBase);
             const windshield = BABYLON.MeshBuilder.CreateBox("playerWindshield", {width: 1.6, height: 0.5, depth: 0.1}, scene); windshield.material = glassMat; windshield.parent = root; windshield.position.y = cabinBase.position.y + 0.1; windshield.position.z = cabinBase.position.z + 2.0 / 2 + 0.05; windshield.scaling.y = 1.3; windshield.rotation.x = Math.PI / 10; shadowGenerator.addShadowCaster(windshield);
             const rearWindow = windshield.clone("playerRearWindow"); rearWindow.material = glassMat; rearWindow.position.z = cabinBase.position.z - 2.0 / 2 - 0.05; rearWindow.rotation.x = -Math.PI / 12; rearWindow.scaling.y = 1.1; rearWindow.parent = root; shadowGenerator.addShadowCaster(rearWindow);
             const spoilerBase = BABYLON.MeshBuilder.CreateBox("playerSpoilerBase", {width: 1.8, height: 0.1, depth: 0.3}, scene); spoilerBase.material = detailMat; spoilerBase.position.y = 0.5; spoilerBase.position.z = -4.2 / 2 - 0.15; spoilerBase.parent = root; shadowGenerator.addShadowCaster(spoilerBase);
             const spoilerWing = BABYLON.MeshBuilder.CreateBox("playerSpoilerWing", {width: 1.9, height: 0.05, depth: 0.5}, scene); spoilerWing.material = detailMat; spoilerWing.position.y = spoilerBase.position.y + 0.15; spoilerWing.position.z = spoilerBase.position.z + 0.1; spoilerWing.rotation.x = -Math.PI / 12; spoilerWing.parent = root; shadowGenerator.addShadowCaster(spoilerWing);
             const wheelMaterial = new BABYLON.StandardMaterial("playerWheelMat", scene); wheelMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1); const wheelThickness = 0.3; wheelRadius = 0.4;
             const wheelFL = BABYLON.MeshBuilder.CreateCylinder("playerWheelFL", {height: wheelThickness, diameter: wheelRadius * 2, tessellation: 16}, scene); wheelFL.material = wheelMaterial; wheelFL.rotation.z = Math.PI / 2; wheelFL.position = new BABYLON.Vector3(1 + wheelThickness / 2, wheelYOffset, 1.5); wheelFL.parent = root; shadowGenerator.addShadowCaster(wheelFL);
             const wheelFR = wheelFL.clone("playerWheelFR"); wheelFR.position.x = -(1 + wheelThickness / 2); wheelFR.parent = root; shadowGenerator.addShadowCaster(wheelFR);
             const wheelRL = wheelFL.clone("playerWheelRL"); wheelRL.position.z = -1.5; wheelRL.parent = root; shadowGenerator.addShadowCaster(wheelRL);
             const wheelRR = wheelFR.clone("playerWheelRR"); wheelRR.position.z = -1.5; wheelRR.parent = root; shadowGenerator.addShadowCaster(wheelRR);
             return root;
          }
        function createAICar(scene, shadowGenerator) { /* ... same ... */
             const root = new BABYLON.TransformNode("aiCarRoot");
             const bodyMat = new BABYLON.StandardMaterial("aiBodyMat", scene); bodyMat.diffuseColor = new BABYLON.Color3(0.1, 0.2, 0.9); bodyMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
             const glassMat = scene.getMaterialByName("playerGlassMat") || new BABYLON.StandardMaterial("aiGlassMat", scene);
             const detailMat = scene.getMaterialByName("playerDetailMat") || new BABYLON.StandardMaterial("aiDetailMat", scene);
             const wheelMaterial = scene.getMaterialByName("playerWheelMat") || new BABYLON.StandardMaterial("aiWheelMat", scene);
             const chassis = BABYLON.MeshBuilder.CreateBox("aiChassis", {width: 2.2, height: 0.7, depth: 4.2}, scene); chassis.material = bodyMat; chassis.position.y = 0; chassis.parent = root; shadowGenerator.addShadowCaster(chassis);
             const cabinBase = BABYLON.MeshBuilder.CreateBox("aiCabinBase", {width: 1.7, height: 0.6, depth: 2.0}, scene); cabinBase.material = bodyMat; cabinBase.position.y = 0.7 / 2 + 0.6 / 2; cabinBase.position.z = -0.5; cabinBase.parent = root; shadowGenerator.addShadowCaster(cabinBase);
             const windshield = BABYLON.MeshBuilder.CreateBox("aiWindshield", {width: 1.6, height: 0.5, depth: 0.1}, scene); windshield.material = glassMat; windshield.parent = root; windshield.position.y = cabinBase.position.y + 0.1; windshield.position.z = cabinBase.position.z + 2.0 / 2 + 0.05; windshield.scaling.y = 1.3; windshield.rotation.x = Math.PI / 10; shadowGenerator.addShadowCaster(windshield);
             const rearWindow = windshield.clone("aiRearWindow"); rearWindow.material = glassMat; rearWindow.position.z = cabinBase.position.z - 2.0 / 2 - 0.05; rearWindow.rotation.x = -Math.PI / 12; rearWindow.scaling.y = 1.1; rearWindow.parent = root; shadowGenerator.addShadowCaster(rearWindow);
             const wheelThickness = 0.3; const aiWheelRadius = 0.4; const aiWheelYOffset = -0.2;
             const wheelFL = BABYLON.MeshBuilder.CreateCylinder("aiWheelFL", {height: wheelThickness, diameter: aiWheelRadius * 2, tessellation: 16}, scene); wheelFL.material = wheelMaterial; wheelFL.rotation.z = Math.PI / 2; wheelFL.position = new BABYLON.Vector3(1 + wheelThickness / 2, aiWheelYOffset, 1.5); wheelFL.parent = root; shadowGenerator.addShadowCaster(wheelFL);
             const wheelFR = wheelFL.clone("aiWheelFR"); wheelFR.position.x = -(1 + wheelThickness / 2); wheelFR.parent = root; shadowGenerator.addShadowCaster(wheelFR);
             const wheelRL = wheelFL.clone("aiWheelRL"); wheelRL.position.z = -1.5; wheelRL.parent = root; shadowGenerator.addShadowCaster(wheelRL);
             const wheelRR = wheelFR.clone("aiWheelRR"); wheelRR.position.z = -1.5; wheelRR.parent = root; shadowGenerator.addShadowCaster(wheelRR);
             root.metadata = { health: 1 };
             return root;
          }


        // --- Powerup Creation Function --- (No changes)
        function createPowerup(type, position) { /* ... same ... */
             let powerupMesh; const powerupSize = 1.5;
             if (type === 'shooter') { powerupMesh = BABYLON.MeshBuilder.CreateBox(`powerup_${type}_${BABYLON.Tools.RandomId()}`, { size: powerupSize }, scene); const mat = new BABYLON.StandardMaterial(`powerupMat_${type}`, scene); mat.diffuseColor = new BABYLON.Color3(0, 1, 1); mat.emissiveColor = new BABYLON.Color3(0, 0.5, 0.5); powerupMesh.material = mat; }
             else { powerupMesh = BABYLON.MeshBuilder.CreateSphere(`powerup_${type}_${BABYLON.Tools.RandomId()}`, { diameter: powerupSize }, scene); const mat = new BABYLON.StandardMaterial(`powerupMat_${type}`, scene); mat.diffuseColor = new BABYLON.Color3(1, 1, 0); mat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0); powerupMesh.material = mat; }
             powerupMesh.position = position;
             powerupMesh.metadata = { type: type, originalPosition: position.clone(), respawnTimer: null };
             powerupsInScene.push(powerupMesh);
         }

        // --- Projectile & Explosion Functions --- (No changes)
        function firePlayerProjectile() { /* ... */
             if (!carRoot || !playerIsActive) return; initializeAudio(); console.log("Player Firing projectile!");
             const projectile = createProjectileBase("playerProj", carRoot, new BABYLON.Color3(1, 0.5, 0), new BABYLON.Color3(0.8, 0.3, 0));
             playerProjectiles.push(projectile);
         }
        function fireAIProjectile() { /* ... */
             if (!aiCarRoot || !aiIsActive) return; initializeAudio(); console.log("AI Firing projectile!");
             const projectile = createProjectileBase("aiProj", aiCarRoot, new BABYLON.Color3(0.1, 1, 0.1), new BABYLON.Color3(0.1, 0.6, 0.1));
             aiProjectiles.push(projectile); aiActivePowerup = null;
         }
        function createProjectileBase(baseName, sourceCar, diffuseColor, emissiveColor) { /* ... same ... */
              const projectileSize = 0.5; const projectile = BABYLON.MeshBuilder.CreateSphere(`${baseName}_${BABYLON.Tools.RandomId()}`, { diameter: projectileSize }, scene);
              const mat = new BABYLON.StandardMaterial(`${baseName}Mat`, scene); mat.diffuseColor = diffuseColor; mat.emissiveColor = emissiveColor; projectile.material = mat;
              const projectileDirection = sourceCar.getDirection(new BABYLON.Vector3(0, 0, -1)); const startOffset = 3.0;
              const visualBackDirection = sourceCar.getDirection(new BABYLON.Vector3(0, 0, -1));
              projectile.position = sourceCar.position.add(visualBackDirection.scale(startOffset)); projectile.position.y = sourceCar.position.y + 0.2;
              const trailParticles = new BABYLON.ParticleSystem(`trail_${projectile.id}`, 500, scene); trailParticles.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/particles/textures/flare.png", scene);
              trailParticles.emitter = projectile; trailParticles.minEmitBox = new BABYLON.Vector3(-0.1, -0.1, -0.1); trailParticles.maxEmitBox = new BABYLON.Vector3(0.1, 0.1, 0.1);
              trailParticles.color1 = new BABYLON.Color4(diffuseColor.r, diffuseColor.g, diffuseColor.b, 1.0); trailParticles.color2 = new BABYLON.Color4(emissiveColor.r, emissiveColor.g, emissiveColor.b, 0.8); trailParticles.colorDead = new BABYLON.Color4(0.2, 0.2, 0.2, 0.0);
              trailParticles.minSize = 0.1; trailParticles.maxSize = 0.3; trailParticles.minLifeTime = 0.1; trailParticles.maxLifeTime = 0.3; trailParticles.emitRate = 300;
              trailParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE; trailParticles.gravity = new BABYLON.Vector3(0, -2, 0);
              trailParticles.direction1 = new BABYLON.Vector3(-0.2, -0.2, -0.2); trailParticles.direction2 = new BABYLON.Vector3(0.2, 0.2, 0.2);
              trailParticles.minEmitPower = 0.5; trailParticles.maxEmitPower = 1.5; trailParticles.updateSpeed = 0.008; trailParticles.start();
              projectile.metadata = { direction: projectileDirection.normalize(), creationTime: Date.now(), trailSystem: trailParticles, owner: baseName.startsWith("player") ? "player" : "ai" };
              return projectile;
         }
        function createExplosion(position) { /* ... */
              console.log("Creating explosion at:", position);
              const explosionParticles = new BABYLON.ParticleSystem("explosion", 2000, scene); explosionParticles.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/particles/textures/flare.png", scene);
              explosionParticles.emitter = position; explosionParticles.minEmitBox = new BABYLON.Vector3(-0.2, 0, -0.2); explosionParticles.maxEmitBox = new BABYLON.Vector3(0.2, 0.2, 0.2);
              explosionParticles.color1 = new BABYLON.Color4(1, 0.8, 0, 1.0); explosionParticles.color2 = new BABYLON.Color4(1, 0, 0, 1.0); explosionParticles.colorDead = new BABYLON.Color4(0.2, 0, 0, 0.0);
              explosionParticles.minSize = 0.5; explosionParticles.maxSize = 1.5; explosionParticles.minLifeTime = 0.3; explosionParticles.maxLifeTime = 0.8;
              explosionParticles.emitRate = 1500; explosionParticles.manualEmitCount = 1500; explosionParticles.maxEmitPower = 0;
              explosionParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE; explosionParticles.gravity = new BABYLON.Vector3(0, -9.81, 0);
              explosionParticles.direction1 = new BABYLON.Vector3(-1, -1, -1); explosionParticles.direction2 = new BABYLON.Vector3(1, 1, 1);
              explosionParticles.minEmitPower = 10; explosionParticles.maxEmitPower = 25; explosionParticles.updateSpeed = 0.01;
              explosionParticles.start(); explosionParticles.targetStopDuration = 0.8; explosionParticles.disposeOnStop = true;
              playExplosionSound();
           }
        function playExplosionSound() { /* ... */
               if (!audioContext) { console.warn("AudioContext not initialized, cannot play sound."); return; }
               try {
                   const duration = 0.5; const bufferSize = audioContext.sampleRate * duration; const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate); const output = buffer.getChannelData(0);
                   for (let i = 0; i < bufferSize; i++) { output[i] = (Math.random() * 2 - 1) * 0.5; }
                   const source = audioContext.createBufferSource(); source.buffer = buffer;
                   const gainNode = audioContext.createGain(); gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                   const filter = audioContext.createBiquadFilter(); filter.type = "lowpass"; filter.frequency.setValueAtTime(1000, audioContext.currentTime); filter.frequency.linearRampToValueAtTime(100, audioContext.currentTime + duration * 0.5);
                   source.connect(filter); filter.connect(gainNode); gainNode.connect(audioContext.destination);
                   source.start(audioContext.currentTime); /*console.log("Playing explosion sound.");*/ source.stop(audioContext.currentTime + duration);
               } catch (e) { console.error("Error playing explosion sound:", e); }
           }

        // --- Tire Screech Sound --- (No changes)
        function playScreechSound() { /* ... */
              if (!audioContext || !screechSound || isScreeching) return; isScreeching = true;
              try {
                  const duration = 0.3; const bufferSize = audioContext.sampleRate * duration; const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate); const output = buffer.getChannelData(0);
                  for (let i = 0; i < bufferSize; i++) { output[i] = (Math.random() * 2 - 1) * 0.4; }
                  const source = audioContext.createBufferSource(); source.buffer = buffer;
                  const filter = audioContext.createBiquadFilter(); filter.type = "highpass"; filter.frequency.setValueAtTime(2000, audioContext.currentTime);
                  source.connect(filter); filter.connect(screechSound.gain);
                  screechSound.gain.gain.cancelScheduledValues(audioContext.currentTime); screechSound.gain.gain.setValueAtTime(0.6, audioContext.currentTime); screechSound.gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
                  source.start(audioContext.currentTime); /*console.log("Playing screech sound.");*/
                  source.onended = () => { isScreeching = false; }; source.stop(audioContext.currentTime + duration + 0.1);
              } catch (e) { console.error("Error playing screech sound:", e); isScreeching = false; }
          }


        // --- Gamepad (Controller) Logic ---
         function setupGamepadListeners() { /* ... same ... */
               window.addEventListener("gamepadconnected", (event) => {
                  if (event.gamepad.id.toLowerCase().includes("xbox") || event.gamepad.buttons.length >= 16) {
                      console.log("Gamepad connected:", event.gamepad);
                      controller = event.gamepad; controllerStatusDiv.textContent = `Status: Connected (${controller.id})`; controllerStatusDiv.style.color = '#4CAF50';
                      initializeAudio();
                  } else { console.log("Non-Xbox Gamepad connected:", event.gamepad); }
              });
              window.addEventListener("gamepaddisconnected", (event) => {
                  console.log("Gamepad disconnected:", event.gamepad);
                  if (controller && controller.index === event.gamepad.index) {
                      controller = null; controllerStatusDiv.textContent = "Status: Disconnected"; controllerStatusDiv.style.color = '#F44336';
                      carSpeed = 0; steeringAngle = 0; playerActivePowerup = null; powerupDisplayDiv.textContent = "Powerup: None";
                      if(audioContext && engineSound) engineSound.gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + audioRampTime);
                      if(audioContext && drivingSound) drivingSound.gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + audioRampTime);
                  }
              });
           }

        function handleGamepadInput(deltaTime) {
               isAccelerating = false; if (!controller) return;
              const gamepads = navigator.getGamepads(); const currentControllerState = gamepads[controller.index];
              if (!currentControllerState) { console.warn("Controller state lost during input handling."); controller = null; controllerStatusDiv.textContent = "Status: Disconnected"; controllerStatusDiv.style.color = '#F44336'; carSpeed = 0; steeringAngle = 0; playerActivePowerup = null; powerupDisplayDiv.textContent = "Powerup: None"; return; }
              controller = currentControllerState;
              const axes = controller.axes; const buttons = controller.buttons; const steerInput = axes[0]; const deadzone = 0.15;

              // Steering Logic (Reverted to V33/V34 logic)
              if (Math.abs(steerInput) > deadzone) {
                  const steeringFactor = 1 - Math.abs(carSpeed / (maxSpeed * 1.8));
                  // *** FIX: Reverted Steering Input Effect ***
                  steeringAngle += steerInput * steeringSpeed * steeringFactor; // Stick Right (+ve) -> Angle Increases
              } else {
                  steeringAngle = BABYLON.Scalar.Lerp(steeringAngle, 0, steeringLerpFactor * (deltaTime * 60));
              }
              steeringAngle = Math.max(-maxSteeringAngle, Math.min(maxSteeringAngle, steeringAngle)); // Clamp

              // Standard Controls: RT Accelerates, LT Brakes/Reverses
              const accelInput = buttons[7] ? (buttons[7].value > 0.1 ? buttons[7].value : 0) : 0; // RT (button 7)
              const brakeInput = buttons[6] ? (buttons[6].value > 0.1 ? buttons[6].value : 0) : 0; // LT (button 6)

              // Apply Acceleration/Braking
              if (accelInput > 0) { carSpeed += acceleration * accelInput * (deltaTime * 60); isAccelerating = true; }
              else if (brakeInput > 0) { if (carSpeed > 0.01) carSpeed -= braking * brakeInput * (deltaTime * 60); else carSpeed -= reverseAcceleration * brakeInput * (deltaTime * 60); }
              else { if (Math.abs(carSpeed) > deceleration * deltaTime * 60) carSpeed -= deceleration * Math.sign(carSpeed) * (deltaTime * 60); else if (Math.abs(carSpeed) > 0) carSpeed = 0; }
              carSpeed = Math.max(-maxSpeed / 2, Math.min(maxSpeed, carSpeed));

              // Powerup Activation
              const shootButton = buttons[0];
              if (shootButton && shootButton.pressed && !shootButtonPressed) {
                  initializeAudio(); if (playerActivePowerup === 'shooter') { firePlayerProjectile(); playerActivePowerup = null; powerupDisplayDiv.textContent = "Powerup: None"; shootButtonPressed = true; }
              }
              if (shootButton && !shootButton.pressed) { shootButtonPressed = false; }
           }

        // --- Helper function to update score display ---
        function updateScoreDisplay() {
            if (scoreDisplayDiv) {
                scoreDisplayDiv.textContent = `Score: ${playerScore} - ${aiScore}`;
            }
        }

        // --- Game Loop ---
        function gameLoop() {
            const deltaTime = engine.getDeltaTime() / 1000.0;
            const now = Date.now();

            handleGamepadInput(deltaTime);

            // --- Player Car Movement ---
            if (playerIsActive && carRoot) {
                if (Math.abs(carSpeed) > 0.001) {
                    // Rotation Application: Positive Angle (from Stick Right) -> Positive Rotation (Turn Left)
                    const rotationDelta = steeringAngle * (carSpeed / maxSpeed) * turnFactor * deltaTime; // *** FIX: Apply angle directly ***
                    carRoot.rotation.y += rotationDelta;
                    const wheelCircumference = 2 * Math.PI * wheelRadius; const distanceTraveled = carSpeed * 25 * deltaTime; const wheelRotationDelta = distanceTraveled / wheelCircumference; carRoot.getChildren().forEach(mesh => { if (mesh && mesh.name && mesh.name.startsWith("playerWheel")) { mesh.rotate(BABYLON.Axis.Y, wheelRotationDelta, BABYLON.Space.LOCAL); } });
                } else {
                    steeringAngle = BABYLON.Scalar.Lerp(steeringAngle, 0, steeringLerpFactor * 10 * deltaTime);
                }
                // Movement Vector (Uses Local -Z for forward movement)
                const localMoveDirection = new BABYLON.Vector3(0, 0, -1);
                const worldMoveDirection = carRoot.getDirection(localMoveDirection);
                const moveVector = worldMoveDirection.scale(carSpeed * 60 * deltaTime);
                carRoot.position.addInPlace(moveVector);
                carRoot.position.y = 0.5;
            } else if (!playerIsActive && carRoot) { /* Player inactive */ }


            // --- AI Car Movement & Logic --- (No changes)
            let currentTargetPosition = null;
            if (aiCarRoot && aiIsActive && aiTargetPath.length > 0) {
                // AI Powerup Seeking
                aiTargetPowerup = null; let closestPowerupDist = aiPowerupSeekDistance;
                if (aiActivePowerup === null) {
                    for (const powerup of powerupsInScene) {
                        if (powerup && powerup.isEnabled() && powerup.position) {
                            const distToPowerup = BABYLON.Vector3.Distance(aiCarRoot.position, powerup.position);
                            if (distToPowerup < closestPowerupDist) { closestPowerupDist = distToPowerup; aiTargetPowerup = powerup; }
                        }
                    }
                }
                // Decide target
                if (aiTargetPowerup) {
                    currentTargetPosition = aiTargetPowerup.position;
                    if (closestPowerupDist < powerupCollectionDistance) {
                         aiActivePowerup = aiTargetPowerup.metadata.type; console.log("AI Collected powerup:", aiActivePowerup, "Name:", aiTargetPowerup.name); aiTargetPowerup.setEnabled(false);
                         if (aiTargetPowerup.metadata.respawnTimer) { clearTimeout(aiTargetPowerup.metadata.respawnTimer); }
                         aiTargetPowerup.metadata.respawnTimer = setTimeout(() => { if (aiTargetPowerup && !aiTargetPowerup.isDisposed()) { aiTargetPowerup.position = aiTargetPowerup.metadata.originalPosition.clone(); aiTargetPowerup.setEnabled(true); aiTargetPowerup.metadata.respawnTimer = null; console.log("Respawned powerup:", aiTargetPowerup.metadata.type, "Name:", aiTargetPowerup.name); } else { console.warn("Attempted to respawn disposed powerup:", aiTargetPowerup?.name); } }, powerupRespawnTime);
                         aiTargetPowerup = null; currentTargetPosition = aiTargetPath[aiCurrentTargetIndex];
                    }
                } else {
                    currentTargetPosition = aiTargetPath[aiCurrentTargetIndex];
                    const distanceToWaypoint = BABYLON.Vector3.Distance(aiCarRoot.position, currentTargetPosition);
                    if (distanceToWaypoint < aiWaypointThreshold) { aiCurrentTargetIndex = (aiCurrentTargetIndex + 1) % aiTargetPath.length; currentTargetPosition = aiTargetPath[aiCurrentTargetIndex]; }
                }
                // AI Movement
                const directionToTarget = currentTargetPosition.subtract(aiCarRoot.position).normalize();
                const targetRotationY = Math.atan2(directionToTarget.x, directionToTarget.z); let currentRotationY = aiCarRoot.rotation.y; let rotationDiff = targetRotationY - currentRotationY;
                if (rotationDiff > Math.PI) rotationDiff -= 2 * Math.PI; if (rotationDiff < -Math.PI) rotationDiff += 2 * Math.PI;
                aiCarRoot.rotation.y += rotationDiff * aiTurnSpeed;
                const aiForward = aiCarRoot.getDirection(BABYLON.Vector3.Forward()); // Local Z+
                const aiMoveVector = aiForward.scale(aiCarSpeed * 60 * deltaTime);
                aiCarRoot.position.addInPlace(aiMoveVector); aiCarRoot.position.y = 0.5;
                 // Animate AI wheels
                 if (aiCarRoot.getChildren) { const aiWheelCircumference = 2 * Math.PI * wheelRadius; const aiDistanceTraveled = aiCarSpeed * 25 * deltaTime; const aiWheelRotationDelta = aiDistanceTraveled / aiWheelCircumference; aiCarRoot.getChildren().forEach(mesh => { if (mesh && mesh.name && mesh.name.startsWith("aiWheel")) { mesh.rotate(BABYLON.Axis.Y, aiWheelRotationDelta, BABYLON.Space.LOCAL); } }); }
                // AI Shooting
                if (aiActivePowerup === 'shooter' && playerIsActive && carRoot && now > aiShootCooldown) {
                    const vectorToPlayer = carRoot.position.subtract(aiCarRoot.position); const distanceToPlayer = vectorToPlayer.length();
                    if (distanceToPlayer < aiShootingRange) {
                        const directionToPlayerNorm = vectorToPlayer.normalize(); const dotProduct = BABYLON.Vector3.Dot(aiForward, directionToPlayerNorm);
                        if (dotProduct > Math.cos(aiShootingAngle)) { fireAIProjectile(); aiShootCooldown = now + aiShootInterval; }
                    }
                }
            } else if (aiCarRoot && !aiIsActive) { /* AI waiting for respawn */ }
              else if (!aiCarRoot) { console.warn("AI Car Root not found in game loop."); }


            // --- Powerup Collection Logic (Player) --- (No changes)
            for (let i = powerupsInScene.length - 1; i >= 0; i--) {
                const powerup = powerupsInScene[i];
                if (powerup && powerup.position && powerup.isEnabled() && playerIsActive && carRoot) {
                    powerup.rotation.y += 0.05; powerup.rotation.x += 0.02;
                    const dist = BABYLON.Vector3.Distance(carRoot.position, powerup.position);
                    if (dist < powerupCollectionDistance && playerActivePowerup === null) {
                        playerActivePowerup = powerup.metadata.type; console.log("Player Collected powerup:", playerActivePowerup, "Name:", powerup.name); powerupDisplayDiv.textContent = `Powerup: ${playerActivePowerup.charAt(0).toUpperCase() + playerActivePowerup.slice(1)}`;
                        powerup.setEnabled(false);
                        if (powerup.metadata.respawnTimer) { clearTimeout(powerup.metadata.respawnTimer); }
                        powerup.metadata.respawnTimer = setTimeout(() => { if (powerup && !powerup.isDisposed()) { powerup.position = powerup.metadata.originalPosition.clone(); powerup.setEnabled(true); powerup.metadata.respawnTimer = null; console.log("Respawned powerup:", powerup.metadata.type, "Name:", powerup.name); } else { console.warn("Attempted to respawn disposed powerup:", powerup?.name); } }, powerupRespawnTime);
                    }
                } else if (!powerup) { console.warn(`Powerup at index ${i} is null.`); powerupsInScene.splice(i, 1); }
                  else if (powerup && !powerup.position) { console.warn(`Powerup ${powerup.name} has no position.`); }
            }


            // --- Projectile Update & Collision --- (No changes)
            // Player Projectiles hitting AI
            for (let i = playerProjectiles.length - 1; i >= 0; i--) { /* ... same ... */
                 const proj = playerProjectiles[i];
                 if (proj && !proj.isDisposed()) {
                     const moveDistance = projectileSpeed * 60 * deltaTime; proj.position.addInPlace(proj.metadata.direction.scale(moveDistance));
                     let hitAI = false;
                     if (aiCarRoot && aiIsActive && aiCarRoot.position) {
                         const distToAI = BABYLON.Vector3.Distance(proj.position, aiCarRoot.position);
                         if (distToAI < projectileHitDistance) {
                             hitAI = true; console.log("Player Hit AI Car!"); aiIsActive = false; aiCarRoot.setEnabled(false); createExplosion(aiCarRoot.position.clone());
                             playerScore++; updateScoreDisplay();
                             if (aiRespawnTimer) clearTimeout(aiRespawnTimer);
                             aiRespawnTimer = setTimeout(() => {
                                 if (aiCarRoot && !aiCarRoot.isDisposed() && aiTargetPath.length > 0) {
                                     const respawnIndex = Math.floor(Math.random() * aiTargetPath.length); aiCarRoot.position = aiTargetPath[respawnIndex].clone(); aiCurrentTargetIndex = (respawnIndex + 1) % aiTargetPath.length;
                                     if (aiTargetPath[aiCurrentTargetIndex]) { aiCarRoot.lookAt(aiTargetPath[aiCurrentTargetIndex]); } else { console.warn("AI respawn lookAt target is undefined."); aiCarRoot.rotation = BABYLON.Vector3.Zero(); }
                                     aiCarRoot.setEnabled(true); aiIsActive = true; aiRespawnTimer = null; console.log("AI Car Respawned at index:", respawnIndex);
                                 } else { console.warn("AI Car Root disposed or target path empty before respawn."); }
                             }, aiRespawnTime);
                         }
                     } else if (!aiCarRoot) { console.warn("Player projectile check: AI Car Root is null."); }
                     if (hitAI || (now - proj.metadata.creationTime > projectileLifetime)) {
                         if (!hitAI) { createExplosion(proj.position.clone()); }
                         if (proj.metadata.trailSystem) { proj.metadata.trailSystem.stop(); proj.metadata.trailSystem.dispose(); }
                         proj.dispose(); playerProjectiles.splice(i, 1);
                     }
                 } else { playerProjectiles.splice(i, 1); }
             }
             // AI Projectiles hitting Player
             for (let i = aiProjectiles.length - 1; i >= 0; i--) { /* ... same ... */
                 const proj = aiProjectiles[i];
                 if (proj && !proj.isDisposed()) {
                     const moveDistance = projectileSpeed * 60 * deltaTime; proj.position.addInPlace(proj.metadata.direction.scale(moveDistance));
                     let hitPlayer = false;
                     if (carRoot && playerIsActive && carRoot.position) {
                         const distToPlayer = BABYLON.Vector3.Distance(proj.position, carRoot.position);
                         if (distToPlayer < projectileHitDistance) {
                             hitPlayer = true; console.log("Player Hit by AI!"); playerIsActive = false; carRoot.setEnabled(false);
                             createExplosion(carRoot.position.clone());
                             aiScore++; updateScoreDisplay();
                             if (playerRespawnTimer) clearTimeout(playerRespawnTimer);
                             playerRespawnTimer = setTimeout(() => {
                                 if (carRoot && !carRoot.isDisposed() && aiTargetPath.length > 0) {
                                     const respawnIndex = Math.floor(Math.random() * aiTargetPath.length); carRoot.position = aiTargetPath[respawnIndex].clone(); carRoot.position.x += 5; carRoot.rotation.y = Math.random() * Math.PI * 2;
                                     carSpeed = 0; steeringAngle = 0; carRoot.setEnabled(true); playerIsActive = true; playerRespawnTimer = null;
                                     console.log("Player Respawned near index:", respawnIndex);
                                 } else { console.warn("Player Car Root disposed or target path empty before respawn."); }
                             }, playerRespawnTime);
                         }
                     } else if (!carRoot) { console.warn("AI projectile check: Player Car Root is null."); }
                     if (hitPlayer || (now - proj.metadata.creationTime > projectileLifetime)) {
                         if (!hitPlayer) { createExplosion(proj.position.clone()); }
                         if (proj.metadata.trailSystem) { proj.metadata.trailSystem.stop(); proj.metadata.trailSystem.dispose(); }
                         proj.dispose(); aiProjectiles.splice(i, 1);
                     }
                 } else { aiProjectiles.splice(i, 1); }
             }


            // --- Update Audio --- (No changes)
            if (audioContext && engineSound && drivingSound && screechSound) { /* ... same ... */
                 const speedRatio = Math.abs(carSpeed / maxSpeed); const targetTime = audioContext.currentTime + audioRampTime;
                 const targetFreq = engineSound.baseFreq + (engineSound.maxFreq - engineSound.baseFreq) * speedRatio; engineSound.oscillator.frequency.setTargetAtTime(targetFreq, audioContext.currentTime, 0.03);
                 const targetGain = (isAccelerating || speedRatio > 0.1) ? Math.min(engineSound.maxGain, speedRatio * engineSound.maxGain * 2.0) : 0; engineSound.gain.gain.linearRampToValueAtTime(targetGain, targetTime);
                 const targetDrivingGain = speedRatio > 0.05 ? drivingSound.maxGain * Math.min(1, speedRatio * 1.5) : 0; drivingSound.gain.gain.linearRampToValueAtTime(targetDrivingGain, targetTime);
                 if (Math.abs(steeringAngle) > screechThresholdAngle && speedRatio > screechThresholdSpeed && !isScreeching) { playScreechSound(); }
             }

            // Update Speedometer
            const displaySpeed = Math.abs(carSpeed * 100).toFixed(0);
            speedometerDiv.textContent = `Speed: ${displaySpeed}`;

            // Render
            if (scene && scene.isReady()) {
                scene.render();
            }
        }

        // --- Initialization ---
        scene = createScene();
        engine.runRenderLoop(gameLoop);
        window.addEventListener('resize', function(){ engine.resize(); });

    </script>

</body>
</html>
```

**Summary of Fix:**

1.  **Steering Input:** In `handleGamepadInput`, changed `steeringAngle -= ...` to `steeringAngle += ...`.
2.  **Rotation Application:** In `gameLoop`, changed `rotationDelta = steeringAngle * ...` to `rotationDelta = -steeringAngle * ...`.

This combination should now reverse the steering compared to the previous version. Please refresh and confirm if Left Stick now turns Left and Right Stick turns Rig